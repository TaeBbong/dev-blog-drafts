## Ch1. Flutter의 매력 Hot Reload의 원리

### 들어가며

플러터를 처음 접한 사람들이 가장 놀란 와우 포인트는 아마 Hot Reload, Hot Restart 일 것입니다.

크게 보면 Dart 코드가 컴파일 되고,
이 글에서는 플러터 엔진이 어떻게 동작하는지가 아닌, 내가 작성한 Dart 코드가 어떻게 기기로 전달되어 실행되는지, Hot Reload와 Hot Restart는 어떻게 그렇게 빨리 기기로 전달되는지를 이해할 것입니다.

### Dart VM이 컴파일 하는 두가지 방식

첫번째 단계는 Dart에서 시작합니다. 플러터 코드는 다트를 기반으로 작성되는데, 다트는 컴파일 언어로 대부분의 언어들과 비슷한 컴파일 과정을 거치게 됩니다. 이때 다트는 두가지의 컴파일 방식(AOT, JIT)을 제공합니다.

먼저 요약하자면, **release / profile 환경에서는 AOT 방식으로 컴파일**이 되고, **debug 환경에서는 JIT 방식**으로 컴파일됩니다.

> profile 모드는 AOT 코드에 디버그 서비스를 일부 남겨 두는 점만 다릅니다. 아래 내용에서는 profile 모드에 대한 설명은 하지 않고 release(AOT), debug(JIT)에 대한 내용만 담습니다.

#### Dart - AOT 컴파일

**AOT(Ahead of Time)** 컴파일은 우리가 대부분의 상황에서 컴파일이라고 하면 생각나는 방식과 거의 동일합니다.
우리가 작성한 Dart 코드는 플러터 엔진에서 돌아가기 위해 기계어로 변환되는 컴파일 과정이 당연 필요합니다.
이 과정에서 AOT 컴파일은 단순히 Dart 코드를 기계어로 변환하는 것뿐만 아니라 **트리 쉐이킹, 인라이닝, 레지스터 할당 최적화** 등 코드를 최적화하는 여러 단계를 거칩니다. 이를 통해 좀 더 용량이 작은, 최적화된 바이너리가 생성됩니다.

이는 앱 형태로 패키징되어 실행할 기기에 전달되는데, 이 바이너리를 실행하기 위한 Dart 의존성은 **precompiled runtime**으로, JIT 컴파일러를 제거한 경량화된 VM 구성만 앱에 포함되어 무사히 플러터 엔진의 역할을 수행합니다.

좀 더 자세한 단계별 설명은 아래와 같습니다.

| 단계                     | 호스트(빌드 머신)                                                                                                                                   | 디바이스(실제 사용자 기기)                                                             |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| **1. 빌드 명령**         | `flutter build apk` / `flutter build ios` (Release)                                                                                                 | —                                                                                      |
| **2. 프론트엔드 컴파일** | `frontend_server`가 모든 Dart 파일을 **Kernel IR** 로 컴파일                                                                                        | —                                                                                      |
| **3. gen_snapshot**      | 동일 Kernel IR을 아키텍처별 **머신코드**로 AOT 컴파일<br>→ `vm_snapshot_data / instr` + `isolate_snapshot_data / instr` 총 4개의 스냅샷 버퍼를 생성 | —                                                                                      |
| **4. 최적화**            | **트리 쉐이킹**·DCE·인라이닝·상수폴딩 등으로 코드·리소스 최소화                                                                                     | —                                                                                      |
| **5. 패키징**            | Android → 4 스냅샷을 `assets/flutter_assets` 또는 `libapp.so`에 포함<br>iOS → `App.framework` 내부 심볼(`kDartVmSnapshot…`)로 포함                  | —                                                                                      |
| **6. 설치 & 로딩**       | 실 기기에 앱 설치, 실행                                                                                                                             | OS가 엔진 라이브러리를 로드 → **precompiled runtime** 초기화                           |
| **7. Isolate 부팅**      | —                                                                                                                                                   | 엔진이 스냅샷 4 버퍼를 **Read+Execute** 로 맵핑 → `main()` 네이티브 코드 직접 실행     |
| **8. 실행**              | —                                                                                                                                                   | VM은 **JIT 컴파일러가 제거**돼 코드 생성 없이 즉시 실행<br>GC·Isolate 관리 기능만 유지 |

#### Dart - JIT 컴파일

두번째는 **JIT(Just in Time)** 컴파일입니다. 여기서는 **Frontend Server** 프로세스가 Dart 코드를 **Kernel AST**로 변환하며, 이는 실행할 기기로 바로 전송되며 기기 내에서 **스크립트 스냅샷(`snapshot_blob.bin`)** 형태의 바이너리로 저장됩니다.
런타임에는 Dart VM JIT 컴파일러가 함수 호출 시점에 해당 바이트코드를 기계어로 변환합니다.

그러면 아무래도 AOT 컴파일에서 만들어진 최적화된 바이너리보다 무겁겠죠? 뿐만 아니라 런타임에서 실행하기 위한 구성 요소들도 더 많습니다. 각종 디버깅 정보와 도구, 런타임을 포함하여 **앱 크기는 AOT 컴파일 거친 앱보다 더 크게** 됩니다.

대신 그 덕분에 **Hot Reload**가 가능해집니다.
개발자가 디버깅 과정에서 앱을 실행시켰다고 가정해봅시다. 그렇다면 개발자 PC에는 Frontend Server 프로세스가 구동됩니다.
실행 기기에서는 앱 파일과 함께 패키징된 **Flutter Engine, Dart VM(JIT) 및 디버그 도구**가 함께 동작합니다.
이때 개발자가 코드를 수정하고 저장, Hot Reload를 실행시키면 IDE는 바뀐 `.dart` 파일을 개발자 PC의 flutter-tools에 전달합니다.
이를 통해 Frontend Server 프로세스는 변화한 코드에 대해 부분적인 컴파일을 즉시 실시합니다. 이 과정은 수 ms밖에 걸리지 않습니다.
그렇게 컴파일된 **Kernel IR** 파일은 실행 기기에서 돌고 있는 Dart VM으로 전송됩니다.
실행 기기 내의 Dart VM은 필요한 클래스 부분들을 교체하고 필요한 함수만 즉시 JIT 재컴파일을 실시합니다.
이와 같은 과정을 거쳐 아주 작은 시간 내에 변화한 부분만 재컴파일 과정을 거쳐 실행 기기에 전달되는 것입니다.

그렇다면 **Hot Restart**는 어떨까요?
Hot Restart를 실행시키면 실행 기기에서 돌고 있던 main 함수를 비롯한 Isolate 프로세스들이 종료됩니다.
여러 객체들을 포함한 말그대로 State들이 전부 지워지게 되는 것입니다.
그와 동시에 개발자 PC의 Frontend Server는 부분적으로 컴파일했던 Hot Reload와 달리, 전체 Kernel IR을 컴파일합니다.
컴파일된 Kernel IR 파일은 실행 기기의 Dart VM으로 전달됩니다. 이때 다시 실행하기 위해 새로운 Isolate 프로세스를 시작합니다.
이미 Dart VM, Flutter engine은 무언가를 실행시킬 준비가 되어있기 때문에 앱을 아예 새로 시작하는 것보다 한참 빠르게 동작합니다.

자세한 단계별 설명은 다음과 같습니다.

| 단계                     | 호스트(개발자 PC)                                                                                                                                 | 디바이스(에뮬레이터·실기기)                                                       |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| **1. 빌드 명령**         | `flutter run` (Debug) 실행                                                                                                                        | —                                                                                 |
| **2. 프론트엔드 컴파일** | `frontend_server`가 모든 Dart 파일을 **Kernel IR** 로 컴파일 (캐시 유지)                                                                          | —                                                                                 |
| **3. 패키징**            | • `libflutter.so`/`Flutter.framework`(엔진 + Dart VM JIT) 포함<br>• `app.dill` → `kernel_blob.bin`<br>• 서비스 프로토콜·DevTools 디버그 심볼 포함 | —                                                                                 |
| **4. 설치 & 로딩**       | adb / Xcode를 통해 APK·IPA 설치                                                                                                                   | OS가 엔진 라이브러리 로드 → **Dart VM JIT 초기화**                                |
| **5. Isolate 부팅**      | —                                                                                                                                                 | `kernel_blob.bin` 읽어 **스크립트 스냅샷** 생성 → `main()` Isolate 실행           |
| **6. 이벤트 루프**       | IDE > DevFS 채널로 입력·명령 전송                                                                                                                 | UI 스레드(위젯 빌드) ↔ GPU 스레드(래스터) ↔ Platform 스레드(입력)                 |
| **7. Hot Reload**        | 저장(Ctrl-S) → 수정 파일 목록 전달 → `frontend_server`가 **증분 .dill** 생성 → VM Service로 푸시                                                  | VM이 클래스 바이트코드 갱신 → 변경 함수 **즉시 JIT** → `reassemble()` → 새 프레임 |
| **8. Hot Restart**       | `R` 키 → 새 스냅샷 전체 전송                                                                                                                      | 기존 Isolate 종료 → 새 Isolate 부팅 (상태 초기화)                                 |
| **9. 디버깅**            | DevTools, Observatory, 로그, 메모리·CPU 프로파일링                                                                                                | VM Service로 실시간 통계 제공                                                     |

### Flutter 엔진이 컴파일 된 앱을 실행하는 방법
